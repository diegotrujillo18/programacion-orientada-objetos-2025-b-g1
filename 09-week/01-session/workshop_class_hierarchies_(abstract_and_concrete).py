# -*- coding: utf-8 -*-
"""Workshop Class Hierarchies (Abstract and Concrete).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1fSDYzAlneXMUKCmHpelKS_jP2Rd_7yoR
"""

from abc import ABC, abstractmethod
import math

# ==============================================================
# CLASE BASE ABSTRACTA - POO
# HECHO POR: Juan Diego Trujillo Narvaez
# ==============================================================

class FiguraGeometrica(ABC):
    """Clase base abstracta que define la estructura com√∫n de las figuras geom√©tricas."""

    def __init__(self, color: str):
        if not isinstance(color, str) or not color.strip():
            raise ValueError("El color debe ser una cadena de texto no vac√≠a.")
        self._color = color.strip()  # Encapsulamiento

    @abstractmethod
    def area(self) -> float:
        """Este ser√° el m√©todo abstracto que calcular√° el √°rea de la figura."""
        raise NotImplementedError

    @abstractmethod
    def perimetro(self) -> float:
        """Este ser√° el m√©todo abstracto que calcular√° el per√≠metro de la figura."""
        raise NotImplementedError

    def descripcion(self) -> str:
        """Devuelve una descripci√≥n general de la figura."""
        return f"Figura de color {self._color}"



# SUBCLASE: RECT√ÅNGULO
class Rectangulo(FiguraGeometrica):
    def __init__(self, ancho: float, alto: float, color: str):
        super().__init__(color)
        self.__ancho = self._validar_dimension(ancho, "ancho")
        self.__alto = self._validar_dimension(alto, "alto")

    @staticmethod
    def _validar_dimension(valor: float, nombre: str) -> float:
        if not isinstance(valor, (int, float)):
            raise ValueError(f"{nombre} debe ser num√©rico (int o float).")
        valor = float(valor)
        if valor <= 0:
            raise ValueError(f"{nombre} debe ser positivo.")
        return valor

    @property
    def ancho(self) -> float:
        return self.__ancho

    @property
    def alto(self) -> float:
        return self.__alto

    def area(self) -> float:
        return self.__ancho * self.__alto

    def perimetro(self) -> float:
        return 2 * (self.__ancho + self.__alto)

    def descripcion(self) -> str:
        return f"Rect√°ngulo color {self._color} de {self.__ancho} x {self.__alto}"



# SUBCLASE: C√çRCULO
class Circulo(FiguraGeometrica):
    def __init__(self, radio: float, color: str):
        super().__init__(color)
        self.__radio = self._validar_radio(radio)

    @staticmethod
    def _validar_radio(valor: float) -> float:
        if not isinstance(valor, (int, float)):
            raise ValueError("El radio debe ser num√©rico (int o float).")
        valor = float(valor)
        if valor <= 0:
            raise ValueError("El radio debe ser positivo.")
        return valor

    @property
    def radio(self) -> float:
        return self.__radio

    def area(self) -> float:
        return math.pi * (self.__radio ** 2)

    def perimetro(self) -> float:
        return 2 * math.pi * self.__radio

    def descripcion(self) -> str:
        return f"C√≠rculo color {self._color} de radio {self.__radio}"


# SUBCLASE: TRI√ÅNGULO
class Triangulo(FiguraGeometrica):
    def __init__(self, lado1: float, lado2: float, lado3: float, color: str):
        super().__init__(color)
        a = self._validar_lado(lado1, "lado1")
        b = self._validar_lado(lado2, "lado2")
        c = self._validar_lado(lado3, "lado3")
        if not self._cumple_desigualdad(a, b, c):
            raise ValueError("Los lados no cumplen la desigualdad triangular (a+b>c, a+c>b, b+c>a).")
        self.__lado1, self.__lado2, self.__lado3 = a, b, c

    @staticmethod
    def _validar_lado(valor: float, nombre: str) -> float:
        if not isinstance(valor, (int, float)):
            raise ValueError(f"{nombre} debe ser num√©rico (int o float).")
        valor = float(valor)
        if valor <= 0:
            raise ValueError(f"{nombre} debe ser positivo.")
        return valor

    @staticmethod
    def _cumple_desigualdad(a: float, b: float, c: float) -> bool:
        return (a + b > c) and (a + c > b) and (b + c > a)

    @property
    def lado1(self) -> float:
        return self.__lado1

    @property
    def lado2(self) -> float:
        return self.__lado2

    @property
    def lado3(self) -> float:
        return self.__lado3

    def area(self) -> float:
        # F√≥rmula de Her√≥n
        s = self.perimetro() / 2.0
        a, b, c = self.__lado1, self.__lado2, self.__lado3
        area_sq = max(0.0, s * (s - a) * (s - b) * (s - c))
        return math.sqrt(area_sq)

    def perimetro(self) -> float:
        return self.__lado1 + self.__lado2 + self.__lado3

    def descripcion(self) -> str:
        return f"Tri√°ngulo color {self._color} con lados {self.__lado1}, {self.__lado2}, {self.__lado3}"



# MEN√ö PRINCIPAL INTERACTIVO
def crear_figura():
    print("\n======= CREACI√ìN DE FIGURA GEOM√âTRICA =======")
    print("1. Rect√°ngulo")
    print("2. C√≠rculo")
    print("3. Tri√°ngulo")
    print("0. Volver al men√∫ principal")

    opcion = input("Seleccione una opci√≥n: ").strip()
    if opcion == '0':
        return None

    color = input("Ingrese el color de la figura: ").strip()

    try:
        if opcion == '1':
            ancho = float(input("Ingrese el ancho: "))
            alto = float(input("Ingrese el alto: "))
            return Rectangulo(ancho, alto, color)
        elif opcion == '2':
            radio = float(input("Ingrese el radio: "))
            return Circulo(radio, color)
        elif opcion == '3':
            lado1 = float(input("Ingrese el lado 1: "))
            lado2 = float(input("Ingrese el lado 2: "))
            lado3 = float(input("Ingrese el lado 3: "))
            return Triangulo(lado1, lado2, lado3, color)
        else:
            print("Opci√≥n no v√°lida. ‚ùå")
    except ValueError as e:
        print(f"‚ö† Error: {e}")
    return None


def mostrar_figuras(figuras):
    if not figuras:
        print("\n No hay figuras registradas. ‚ö†")
        return
    print("\n--- LISTA DE FIGURAS ---")
    for i, figura in enumerate(figuras, 1):
        print(f"\n[{i}] {figura.descripcion()}")
        print(f"√Årea: {figura.area():.2f}")
        print(f"Per√≠metro: {figura.perimetro():.2f}")


def main():
    figuras = []
    while True:
        print("\n==============================")
        print("        MEN√ö PRINCIPAL  ")
        print("==============================")
        print("1. Crear nueva figura")
        print("2. Mostrar figuras")
        print("0. Salir")

        opcion = input("Seleccione una opci√≥n: ").strip()

        if opcion == '1':
            figura = crear_figura()
            if figura:
                figuras.append(figura)
                print(" La figura creada con √©xito.‚úÖ")
        elif opcion == '2':
            mostrar_figuras(figuras)
        elif opcion == '0':
            print("Saliendo del programa. ¬°Hasta luego! üëã ")
            break
        else:
            print("Opci√≥n inv√°lida ‚ùå Intentalo de nuevo.")


if __name__ == "__main__":
    main()